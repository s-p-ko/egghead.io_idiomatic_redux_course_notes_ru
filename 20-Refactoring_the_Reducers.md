# 20. Рефакторинг редюсеров
[Ссылка на видео](https://egghead.io/lessons/javascript-redux-refactoring-the-reducers)

[Код урока на GitHub](https://github.com/gaearon/todos/tree/20-splitting-the-reducer-files)

Ранее мы удалили `visibilityFilter` редюсер, и поэтому корневой (root) редюсер в приложении теперь объединяет (combines) только один `todos` редюсер. Поскольку `index.js` эффективно действует как прокси для `todos` редюсера, мы полностью удалим `index.js`. Затем мы переименуем `todos.js` в `index.js`, тем самым сделав `todos` новым корневым редюсером.

Файл корневого редюсера теперь содержит `byId`, `allIds`, `activeIds`, и `completedIDs`. Мы собираемся распаковать некоторые из них в отдельные файлы.

Создаем файл с именем `byid.js`, куда мы вставляем код для `byId` редюсера.

Теперь добавим именованный экспорт для селектора под названием `getTodo`, который принимает `state` и `id`, где state (состояние) соответствует состоянию редюсера `byId`. Теперь вернемся к `index.js`, мы можем импортировать редюсер как дефолтный импорт.

Мы также можем импортировать любые связанные селекторы в один объект с импортом пространства имен:

```javascript
import byId, * as fromById from './byid'
```

Теперь, если мы посмотрим на редюсеры, управляющие идентификаторами (IDs), мы заметим, что их код почти такой же, за исключением значения фильтра, с которым они сравнивают `action.filter`.

### Создание `createList`

Давайте создадим новую функцию под названием `createList`, которая принимает `filter` в качестве аргумента .

`createList` вернет другую функцию - редюсер, который обрабатывает `id`s для указанного фильтра - так что его форма состояния представляет собой массив. Чтобы сэкономить время, мы можем скопировать и вставить реализацию из `allIds`, а затем просто заменить литерал `'all'` на аргумент `filter` `createList`'а, чтобы мы могли создать его для любого фильтра.

```javascript
const createList = (filter) => {
  return (state = [], action) => {
    if (action.filter !== filter) {
      return state;
    }
    switch (action.type) {
      case 'RECEIVE_TODOS':
        return action.response.map(todo => todo.id);
      default:
        return state;
    }
  };
};
```

Теперь мы можем полностью удалить код `allIds`, `activeIds`, и `completedIds`редюсеров. Вместо этого мы сгенерируем редюсеры, используя новую функцию `createList`, и передадим ей фильтр в качестве аргумента.

Затем извлеките `createList` функциюв отдельный файл с именем `createList.js`.

Теперь, когда он находится в отдельном файле, мы добавим общедоступный API для доступа к состоянию в виде селектора. Сейчас мы назовем его `getIds` и просто вернем состояние списка (мы можем изменить это в будущем).

#### Заканчивая

Вернувшись в `index.js`, мы импортируем `createList` и любые именованные селекторы из этого файла.

```javascript
import createList, * as fromList from './createList';
```

Мы также переименуем `idsByFilter`  в `listByFilter`, потому что теперь, когда реализация списка находится в отдельном файле, мы будем использовать селектор `getIds`, который он экспортирует.

```javascript
export const getVisibleTodos = (state, filter) => {
  const ids = fromList.getIds(state.listByFilter[filter]);
  return ids.map(id => fromById.getTodo(state.byId, id));
};
```
Поскольку мы также переместили `byId` редюсер в отдельный файл, мы хотим убедиться, что не делаем предположений, что это просто таблица поиска. Имея это в виду, мы будем использовать селектор `fromById.getTodo`, который он экспортирует, и передает его состояние и соответствующий ID.

С помощью этого рефакторинга мы сможем изменить форму состояния любого редюсера в будущем, не внося изменений в кодовую базу.

[Резюме на 3:41 в видео](https://egghead.io/lessons/javascript-redux-refactoring-the-reducers)


<p align="center">
<a href="./19-Updating_the_State_with_the_Fetched_Data.md"><- Предыдущая</a>
<a href="./21-Displaying_Loading_Indicators.md">Следующая -></a>
</p>
